"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addProjectsAndDependenciesFromTask = void 0;
const common_1 = require("@jnxplus/common");
const devkit_1 = require("@nx/devkit");
const child_process_1 = require("child_process");
const fs = require("fs");
const cache_directory_1 = require("nx/src/utils/cache-directory");
const path = require("path");
const utils_1 = require("../utils");
function addProjectsAndDependenciesFromTask(builder, context, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
pluginName) {
    const isVerbose = process.env['NX_VERBOSE_LOGGING'] === 'true';
    const outputFile = path.join(cache_directory_1.projectGraphCacheDirectory, `nx-gradle-deps.json`);
    let command = `${(0, utils_1.getExecutable)()} :projectDependencyTask --outputFile=${outputFile}`;
    if (isVerbose) {
        command += ' --stacktrace';
    }
    (0, child_process_1.execSync)(command, {
        cwd: devkit_1.workspaceRoot,
        stdio: isVerbose ? 'inherit' : 'pipe',
        env: process.env,
        encoding: 'utf-8',
    });
    const projects = JSON.parse(fs.readFileSync(outputFile, 'utf8'));
    addProjects(builder, context, projects);
    addDependencies(builder, projects);
}
exports.addProjectsAndDependenciesFromTask = addProjectsAndDependenciesFromTask;
function addProjects(builder, context, projects) {
    for (const project of projects) {
        if (project.isBuildGradleExists ||
            project.isBuildGradleKtsExists ||
            project.isSettingsGradleExists ||
            project.isSettingsGradleKtsExists) {
            if (!project.isProjectJsonExists) {
                let projectRoot;
                if (project.relativePath) {
                    projectRoot = (0, devkit_1.joinPathFragments)(project.relativePath);
                }
                else {
                    projectRoot = path.relative(devkit_1.workspaceRoot, project.projectDirPath);
                }
                const projectGraphNodeType = (0, common_1.getProjectGraphNodeType)(projectRoot);
                builder.addNode({
                    name: project.name,
                    type: projectGraphNodeType,
                    data: {
                        root: projectRoot,
                        projectType: projectGraphNodeType === 'app' ? 'application' : 'library',
                        targets: {
                            build: {
                                executor: 'nx:noop',
                            },
                        },
                    },
                });
                const files = [];
                if (project.isSettingsGradleExists) {
                    const file = (0, devkit_1.joinPathFragments)(projectRoot, 'settings.gradle');
                    files.push({
                        file: file,
                        hash: 'abc',
                    });
                }
                if (project.isSettingsGradleKtsExists) {
                    const file = (0, devkit_1.joinPathFragments)(projectRoot, 'settings.gradle.kts');
                    files.push({
                        file: file,
                        hash: 'abc',
                    });
                }
                if (project.isBuildGradleExists) {
                    const file = (0, devkit_1.joinPathFragments)(projectRoot, 'build.gradle');
                    files.push({
                        file: file,
                        hash: 'abc',
                    });
                }
                if (project.isBuildGradleKtsExists) {
                    const file = (0, devkit_1.joinPathFragments)(projectRoot, 'build.gradle.kts');
                    files.push({
                        file: file,
                        hash: 'abc',
                    });
                }
                if (project.isGradlePropertiesExists) {
                    const file = (0, devkit_1.joinPathFragments)(projectRoot, 'gradle.properties');
                    files.push({
                        file: file,
                        hash: 'abc',
                    });
                }
                context.fileMap[project.name] = files;
            }
        }
    }
}
function addDependencies(builder, projects) {
    for (const project of projects) {
        if (project.isBuildGradleExists || project.isBuildGradleKtsExists) {
            const projectName = getProjectName(project);
            const buildFile = project.isBuildGradleExists
                ? 'build.gradle'
                : 'build.gradle.kts';
            let projectSourceFile;
            if (project.relativePath) {
                projectSourceFile = (0, devkit_1.joinPathFragments)(project.relativePath, buildFile);
            }
            else {
                const projectRoot = path.relative(devkit_1.workspaceRoot, project.projectDirPath);
                projectSourceFile = (0, devkit_1.joinPathFragments)(projectRoot, buildFile);
            }
            const isVerbose = process.env['NX_VERBOSE_LOGGING'] === 'true';
            if (isVerbose) {
                devkit_1.logger.debug(`workspaceRoot: ${devkit_1.workspaceRoot}`);
                devkit_1.logger.debug(`projectDirPath: ${project.projectDirPath}`);
                devkit_1.logger.debug(`relativePath: ${project.relativePath}`);
                devkit_1.logger.debug(`projectSourceFile: ${projectSourceFile}`);
            }
            const parentProject = getParentProject(projects, project.parentProjectName);
            if (parentProject) {
                const parentProjectName = getProjectName(parentProject);
                builder.addStaticDependency(projectName, parentProjectName, projectSourceFile);
            }
            for (const dependency of project.dependencies) {
                const dependencyName = getProjectName(dependency);
                builder.addStaticDependency(projectName, dependencyName, projectSourceFile);
            }
        }
    }
}
function getProjectName(project) {
    if (project.isProjectJsonExists) {
        const projectJsonPath = path.join(project.projectDirPath, 'project.json');
        const projectJson = JSON.parse(fs.readFileSync(projectJsonPath, 'utf8'));
        return projectJson.name;
    }
    return project.name;
}
function getParentProject(projects, parentProjectName) {
    const project = projects.find((element) => element.name === parentProjectName);
    if (!project) {
        return undefined;
    }
    if (project.isBuildGradleExists ||
        project.isBuildGradleKtsExists ||
        project.isSettingsGradleExists ||
        project.isSettingsGradleKtsExists) {
        return project;
    }
    return getParentProject(projects, project.parentProjectName);
}
//# sourceMappingURL=graph-task.js.map